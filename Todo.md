## Todo

#### select、poll、epoll：

从多路复用说起。拿读来举例，首先我们读的数据来自硬件设备（硬盘、网卡），在linux中，我们把这些可读写的设备都看作文件，用一个fd（文件描述符）来标识。

只有内核空间有资格对这些设备进行访问，所以一个用户进程的IO访问包括两个步骤：内核把这些设备里的数据拷贝至内核空间（所谓的fd就绪），进程再把数据从内核空间拷贝到用户空间。

多路复用机制下，在第二个阶段是阻塞的，但在第一个阶段是非阻塞的。select、poll、epoll就代表了在第一阶段如何选择就绪fd的方法。

- select中把所有需要监视的fd/socket都放在一个数组里，每次调用select()时遍历fd从而找到就绪的fd集合，然后select唤醒进程进行处理。因为是数组，所以有上限。

- poll中把所有需要监视的fd/socket都放在一个链表里，每次调用poll()时遍历fd从而找到就绪的fd集合，然后poll唤醒进程进行处理。

- epoll中只需维持一个Ready队列，每当有fd/socket准备就绪时会调用回调函数，插入到队列之中。epoll使用epoll_wait来轮询Ready队列然后唤醒进程进行处理。
  - 水平触发：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，进程可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。
  - 边缘触发：当epoll_wait检测到某描述符事件就绪并通知应用程序时，进程必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。所以程序要写的很细致。



#### 访问一次URL的流程

首先通过查找本地或者外网DNS解析域名获得IP地址，然后生成一个HTTP请求；TCP分割HTTP报文，与此同时尝试建立与远程主机的TCP连接；为了建立TCP连接，需要通过IP、ARP、ICMP在网络层中寻址；找到子网后，Ethernet帮助我们以广播的形式把数据传到目的MAC地址，最后找到目的地的MAC所在，建立点对点的连接。TCP连接建立完成后服务端返回一个HTTP报文，里面夹带了HTML/CSS/JS，服务器渲染生成我们看到的页面。



#### TCP三次握手

首先客户端发出一个请求连接的包给服务端（SYN=1），包中有客户端的初始序列号；服务端收到这个包后，发出一个确认收到这个序号的包的确认包（SYN=1, ACK=1），并附上服务端的初始序列号给客户端；客户端收到之后发出确认，确认收到了这个初始序列号的包，同时在这个包里可以携带真正的通信的数据。



#### TCP四次挥手

首先客户端发出连接释放请求包给客户端（FIN=1），包中有客户端的序列号；服务端收到这个包后，发出一个确认收到这个序号的包的确认包（ACK=1），但是可能还有数据没发完，只是发出确认收到了这个包，之后服务端可以继续发送数据；当服务端的数据彻底发送完毕之后，发出一个连接释放包（FIN=1）；客户端收到这个包后进入TIME_WAIT状态，等待2MSL（2个报文最大生存时间）后，客户端没有收到重发的连接释放包，说明服务端已经成功收到连接释放包，客户端进入closed状态；



#### TCP流量控制

流量控制针对的是发送方和接收方速度不匹配的问题。如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。

流量控制由滑动窗口协议实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。

流量控制是由**接收者**控制的，它是控制发送者的发送速度从而使接收者来得及接收，防止分组丢失的。



#### TCP拥塞控制

拥塞控制是作用于**网络**的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；

常用的方法就是：

1. **慢开始算法**：发送方维持一个拥塞窗口，拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方的滑动窗口小于等于该拥塞窗口。

   慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。每经过一个传输轮次，拥塞窗口cwnd就加倍。

   > 为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh变量。ssthresh的用法如下：
   >
   > 当cwnd<ssthresh时，使用慢开始算法。
   > 当cwnd>ssthresh时，改用拥塞避免算法。
   > 当cwnd=ssthresh时，慢开始与拥塞避免算法任意

2. **拥塞避免算法**：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口按线性缓慢增长。

3. **快重传算法**：快重传要求接收方在收到一个失序的报文段后就**立即发出重复确认**（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

4. **快恢复算法**：快重传配合使用的还有快恢复算法。当发送方连续收到三个重复确认时，就执行“**乘法减小**”算法，把ssthresh门限减半（为了预防网络发生拥塞）。但是接下去并不执行慢开始算法，考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后**执行拥塞避免算法**，使cwnd缓慢增大。

![preview](https://pic4.zhimg.com/v2-3319d090787d8941cea25376e284679b_r.jpg)



#### TCP和UDP的区别

- TCP可以提供可靠的通信连接，UDP无连接，尽最大努力交付，不用维持复杂的连接状态。
- TCP只支持点对点通信，UDP支持一对一、一对多、多对一的通信模式。
- TCP只支持点对点通信，UDP支持一对一、一对多、多对一的通信模式。
- TCP的报头有20个字节，UDP只有8个字节。



#### HTTP

- 基于TCP/IP通信协议
- 可以传输很多类型/格式的数据对象
- 无连接的协议
- 无状态的协议，但是可以通过cookie、session机制来弥补
- 明文传输，不安全，HTTPS可以解决



#### IOC

IOC是控制反转，最常用的方式是依赖注入，把对象的创建控制权交给IOC容器来管理。在项目启动的时候Spring会读取配置文件里面的bean节点，根据全限定类名使用反射new对象放到IOC容器里，接下来我们在代码里需要用到IOC容器里面的对象时，再通过DI注入（@Autowired）。



#### AOP

AOP是面向切面编程，使用了动态代理模式，能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。
