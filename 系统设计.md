# 分布式系统

分布式？

分布什么？广义：服务的分布；狭义：某个服务分布在多个服务器。

分布式 ——> 服务的分布，业务拆分为多个服务 ——> 每个服务独立部署，对外隐藏细节 ——> 服务内集群部署多个服务器。

简单的可以使用REST（HTTP-JSON）对外提供API来进行服务间的交互，当服务很多时就会变得很复杂。

使用RPC框架来实现分布式系统。

**服务中间的通信**：利用RPC框架中的通信组件（Netty等），可以基于TCP/UDP，也可以基于HTTP。对于服务间的异步处理、流量削峰的需要可以使用消息队列。

**服务中间的寻址和治理**：利用RPC框架中的服务注册中心（Zookeeper），通过编写RPC框架的配置文件把服务发布在服务注册中心。

集群内：负载均衡，一致性问题。

---

分布式锁：对于共享资源的同步控制。（Zookeeper）

分布式中的一致性：针对集群，当修改了某个服务器上数据，如何让集群都执行这个操作，以及不同节点间如何达成共识。（Paxos算法，Zookeeper的ZAB）

---

采用了微服务架构也就意味着服务之间的调用链路会比以前延长了很多，在调用链路上发生故障的几率也就随之增大，所以我们还需要很多技术组件来进行高效的运维。

![preview](https://pic4.zhimg.com/v2-c085b3a4a89ef6008fdc1aa0528fefaf_r.jpg)



## 服务中间的通信

基于RPC的系统依赖关系：

![img](https://pic2.zhimg.com/80/v2-5108c1286a184281a8286de079263f21_1440w.jpg)

基于消息队列的系统依赖关系：

- 点对点模式：一对一
- 发布订阅模式：一对多

![preview](https://pic2.zhimg.com/v2-0e2490aa256d05ca4ad5d0b396113add_r.jpg)



## ZooKeeper

ZooKeeper 是一个典型的分布式数据一致性解决方案，分布式应用程序可以基于 ZooKeeper 实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。

ZooKeeper 本身就是一个分布式程序。为了保证高可用，最好是以集群形态来部署 ZooKeeper，这样只要集群中大部分机器是可用的（能够容忍一定的机器故障），那么 ZooKeeper 本身仍然是可用的。

在谈到分布式的时候，我们通常说的“节点"是指组成集群的每一台机器。然而，在Zookeeper中，“节点"分为两类，第一类同样是指构成集群的机器，我们称之为机器节点；第二类则是指数据模型中的数据单元，我们称之为数据节点一一ZNode。node可以分为持久节点和临时节点两类。

Watcher（事件监听器），是Zookeeper中的一个很重要的特性。Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。

Paxos 算法应该可以说是 ZooKeeper 的灵魂。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。



## 集群

负载均衡的问题

原则：CAP、BASE

一致性算法：Paxos、Raft



## 缓存

淘汰策略

缓存一致性

缓存雪崩、穿透、击穿

数据分布：一致性哈希



## 消息队列

生产者消费者模式

发布订阅模式

使用场景：异步处理、流量削峰、应用解耦

问题：

1. 消息重复消费：即如何保证幂等性，引入唯一ID。
2. 消息丢失：生产者传递过程消息丢失会通过ACK重传机制来解决；MQ消息丢失（掉电）通过消息持久化解决
3. 消息顺序消费：每个线程分别消费一个队列

### Kafka

1. **两种模式**：点对点模式，发布订阅模式。

2. **Broker**：一台kafka服务器就是一个Broker，一个集群由多个Broker组成，一个Broker可以有多个Topic。

3. **Topic**：是Kafka 对数据提供的核心抽象，是发布的数据流的类别或名称。topic在Kafka中，支持多订阅者。对应每一个 topic，Kafka 集群会维护像一个如下这样的分区的日志：

   ![img](https://user-gold-cdn.xitu.io/2019/3/6/16953b447bde1972?imageslim)

4. **Partition**：分区，Kafka可以将一个topic划分为多个分区，会根据分区规则把消息均匀存储到特定分区中，每个分区都是一个队列，以这种方式来实现负载均衡和水平扩展。有点像数据库的分表。

   - topic是逻辑上的概念；partition是物理上的概念，对用户是透明的。producer只需要关心消息发往哪个topic，consumer也只需要关心自己订阅哪个topic。
   - 一个partions，只会被一个consumer消费，因此没有同步的问题。
   - kafka只能保证一个partition中的消息被某个consumer消费时是顺序的；事实上，从Topic角度来说,当有多个partitions时,消息仍不是全局有序的。

5. **Offset**：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。

6. Kafka占用9092端口对外提供服务，Kafka内部依赖于zookeeper来管理集群，zookeeper占用2181端口。



## gRPC

**RPC框架要解决三个问题**：

1. 一个记录服务映射的表：protobuf
2. 对参数的序列化和反序列化：protobuf
3. 进行网络传输：HTTP/2

**代码编写流程**：

1. 用.proto文件定义服务：指定服务名、参数类型、返回值；

   rpc receive (Event) returns (Reply) {}

2. 使用protobuf工具生成两个py文件（stub）；

   - xxx_pb2：对应数据结构
   - xxx_pb2_grpc：对应服务的框架代码

3. 在server代码中import这两个文件，实现我们定义的服务；

4. 在client代码中import xxx_pb2_grpc，调用服务。

**服务调用流程**：

1. 客户端（gRPC Stub）调用 A 方法，发起 RPC 调用；
2. 对参数使用 Protobuf 进行对象序列化压缩并发送；
3. 服务端（gRPC Server）接收到请求后，解码请求体，进行业务逻辑处理；
4. 对返回值使用 Protobuf 进行对象序列化压缩并返回。

