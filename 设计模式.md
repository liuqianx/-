# 设计模式

6个基本原则：

- 开闭原则（Open Close Principle）：对修改闭合，对扩展开放。
- 单一职责原则（Single Responsibility Principle）：一个类做一件事。
- 里氏代换原则（Liskov Substitution Principle）：通过继承的方式来扩展功能，不要改变父类原有功能。
- 依赖倒转原则（Dependence Inversion Principle）：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。？
- 接口隔离原则（Interface Segregation Principle）：一个类引进的依赖尽量的少，不要重复关联接口。
- 迪米特法则（Demeter Principle）：又称最少知道原则，一个类对自己依赖的类知道的越少越好

目的：高内聚，低耦合。（面向接口编程）

分类：创建型模式、结构型模式、行为型模式。



## 创建型模式

#### 1. 简单工厂模式

一个工厂类XxxFactory，里面有一个静态方法，根据我们输入的不同的参数，返回不同的派生自同一个父类（或实现同一个接口）的实例对象。

#### 2. 工厂模式

之所以需要引入工厂模式，是因为我们往往需要使用两种或以上的工厂。

第一步，我们需要选取一个合适的工厂；第二步，和简单工厂一样返回一个实例对象。

> 比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中；显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory。

#### 3. 抽象工厂模式

我们首先定义一个抽象的工厂，在这里定义一个工厂需要生产的产品。继承这个抽象工厂的工厂需要用自己的方式去生产这些产品，工厂内的这些产品之间可能存在联系。

#### 4. 单例模式

饿汉模式：在刚加载类的时候就进行了实例化。

懒汉模式：在需要用的时候才进行实例化。双重校验锁。

> **第一次校验**：使得大部分时间不需要执行同步方法里面的代码，大大提高了性能。
>
> **第二次校验**：防止有其他线程在当前线程进入同步块前就已完成单例的创建。
>
> **volatile**：因为 singleton = new Singleton() 不是一个原子操作，可以分为三步：①为 singleton 分配内存空间；②初始化 singleton；③将 singleton 指向分配的内存空间。如果不加volatile，由于JVM指令重排，多线程下一个线程未完全初始化singleton对象时，另一线程调用getInstance()时返回一个半初始化的对象。

```Java
public class Singleton {
	//私有化构造方法
 	private Singleton(){};
 
 	private static volatile Singleton singleton=null;
 
	public static Singleton getInstance(){
 		//第一次校验
        if(singleton==null){     
            synchronized(Singleton.class){
                //第二次校验
                if(singleton==null){     
                	singleton=new Singleton();
                }
            }
		}
		return singleton;
    }   
}
```

嵌套类：利用了嵌套类可以访问外部类的静态属性和静态方法的特性。

枚举类：



## 结构型模式

#### 1. 代理模式

用一个代理来**隐藏具体实现类的实现细节**。对客户端隐藏真实实现，由代理来负责客户端的所有请求，但是代理本身不会完成实际的业务逻辑。

代理类需要implements其代理的类，代理的内部必然会创建一个真实的实现类，其中核心动作是真实实现类来做的，代理只是在核心动作前后做了一些**“无关紧要”**的事。

静态代理：由程序员创建或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。

动态代理：动态代理类的字节码在程序运行时由Java**反射机制**动态生成，无需程序员手工编写它的源代码。

>在 AOP 中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。
>
>XxxService 接口和 XxxServiceImpl 实现采用JDK动态代理。

<img src="https://user-gold-cdn.xitu.io/2018/10/19/1668ac9a05ed0c11?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="proxy" style="zoom:50%;" />

#### 2. 适配器模式

适配器模式的场景是：有一个现成的类，我们想把它**当作**另一个接口类来使用。

所以我们需要实现这个接口，但是我们现成的类没有完全实现这个接口，需要加一层适配器来进行适配，在适配器中实现现成的类中没有实现的方法，然后我们就可以把这个现成的类看作这个接口类来使用了。

<img src="https://user-gold-cdn.xitu.io/2018/10/19/1668ac9a06512b0c?imageslim" alt="img" style="zoom:50%;" />

#### 3. 装饰器模式

代理只是在核心动作前后做了一些“无关紧要”的事，并没有对真实实现类的功能本身进行增强。而装饰器模式是对真实的实现类**本身**进行增强，拓展在其基础之上的功能。

两者都是对类的方法进行扩展，但装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；而代理模式则强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。



## 行为型模式

#### 1. 观察者模式

观察者模式包括两个操作：观察者**订阅**自己关心的主题，主题有数据变化后**通知**观察者们。

首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者。

观察者模式的目的是一个事件出来了，会有多个不同的类处理相应的信息。

>比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。

























