# 数据库

## MySQL

#### 事务

1. **事务**：事务包含一系列的操作，所有操作都必须完成，否则撤销回滚。
2. **事务的ACID特征**：
   
   - 原子性：要么都做，要么都不做。
   - 一致性：事务开始之前和结束之后，数据库从一个正确的状态到另一个正确的状态，没有破坏数据库定义的一些约束条件。我们通过AID来保证数据库的一致性，保证在宏观上操作状态是正确的。
   - 隔离性：并发的事务之间不互相干扰，一个事务相对于其它并发事务是隔离的。
   - 持久性：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。
3. **MySQL的四种隔离级别**：
   
   - 读取未提交内容：Read_Uncommited，有脏读。所有的事务都可以看到其他未提交事务的执行结果。
   - 读取提交内容：Read_Commited，有不可重复读。一个事务只能看到已经提交的事务做出的改变。
   - 可重复读：Repeated_Read，InnoDB默认的隔离级别，有幻读。**同一行**在**同一个事务内**无论怎么读取都是同一个结果。
   - 串行化：Serializable，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
   
4. **三个问题**：

   - 脏读：读出无效数据，即一个事务读取另一事务还没有提交的数据，另一事务可能**回滚**。

   - 不可重复读：在同一事务内的两次查询数据不一致，即读取了另一事务操作前和提交后的数据。

   - 幻读：是不可重复读的特殊场景，一个是单条数据，一个是多条数据；幻读指在**同一事务内**的两次操作返回的数据条数不一致（两次范围查询中间有个插入操作）。

     > 可通过MVCC + Next-Key Locks解决。读方式有两种，执行简单的select的时候是快照读，其余操作是当前读，例如update操作，在当前快照上update数据是没有意义的，所以，MVCC不能根本上解决幻读的情况，我们还需要Next-Key Locks。Next-Key Locks可以锁住一个范围和记录本身。



#### 索引

1. **Hash索引**：哈希表，只适用于等值查询的场景，不能范围查询。
2. **B+树索引**：B+树，数据在叶子节点上，并且有顺序访问指针。
   - 特点：非叶子节点只进行索引，不保存实际的数据，实际数据都保存在叶子节点中。所有的关键字记录都出现在叶子节点形成的链表中（稠密索引），非叶子节点只是叶子节点的索引（稀疏索引）。
   - 优势：相比于红黑树，**高度**远远小于红黑树。
   - 优势：相比于B-树，B+树的内部节点并没有指向关键字具体信息的指针，所以B+树的内部节点更小；如果把所有属于同一内部节点的关键字放在同一盘块，那么就可以一次性读入内存，**减少I/O次数**。另外叶子节点可以包含一个指向下一叶子节点的指针，**加快顺序存取**，遍历叶子节点就可以完成整棵树的遍历，而B-树需要遍历整棵树。
3. **聚簇索引**：有且只有一个，主键所在的索引即为聚簇索引。聚簇索引的物理存放顺序与索引顺序一致。
4. **非聚簇索引**：二级索引/普通索引，除了聚簇索引以外的索引，用来给主键以外的字段进行索引的索引。非聚簇索引的节点只是索引，同时叶子节点存储有主键的值（InnoDB）/指向对应数据块的指针（MyISAM）。
5. **复合索引**：多个字段作为索引。
   - 最左前缀匹配：首先对复合索引最左边的字段进行排序。
6. **覆盖索引**：如果SQL查找条件为普通索引，则需要扫描两次B+树，即一次普通索引树，一次聚簇索引树。覆盖索引指将这个普通索引，建立到复合索引中去，由此只需要在一颗B+树上就能获得SQL所需的所有列数据。



#### 数据库锁：

**共享锁和排他锁**：读锁/写锁。

**意向锁**：事务打算加行级读/写锁时，首先需要加意向锁。当一个表被上了行级锁时，意向锁避免了其他事务试图获取表级锁时扫描全表。

**表级锁**：开销小，加锁快，不会出现死锁；锁的粒度大，容易发生锁冲突。

**行级锁**：开销大，加锁慢，会出现**死锁**；锁的粒度小，并发度最高。

**乐观锁**：需要自己实现，需要在数据表加上version字段，再在逻辑中使用CAS算法。

**悲观锁**：select ** for update

**MVCC**：Multiversion Concurrency Control，多版本并发控制

- 使用了一种与锁不同的手段来实现并发控制。为了让读写之间也不冲突，读取数据时通过类似快照的方式保存数据。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行。
- InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号加一。
- 在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号**小于等于**当前版本号的数据，这时就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。



## Redis

1. **Redis底层数据结构**：

   - Redis存储形式为key-value。key一定是string；value可以是string、list、hash、set、sortedset
   - RedisObject：Redis的通用数据结构，Redis中的每一个对象都由一个RedisObject结构来表示。
   - dict：是一个哈希表，每个key/value对用一个dictEntry表示；采用**增量式重哈希**，在需要扩展内存时避免一次性对所有的key进行重哈希，而是将重哈希操作分散到对于dict的各个增删改查的操作中去，这种方法能做到每次只对一小部分key进行重哈希。
   - sds：Simple Dynamic String，Redis的字符串结构，可动态扩展；如果是数字会转成long型储存。
     - 字符串对象的编码可以是long/raw/embstr，字符串长度大于39用raw，小于用embstr。
   - ziplist：是经过特殊编码的双向链表，各节点在内存上前后相邻；但是插入会发生realloc/内存拷贝。
     - 很类似数组，不同于数组的是ziplist每个元素所占的空间可变。

   - quicklist：也是一个双向链表，每个节点储存的都是一个ziplist；quicklist结合了双向链表和ziplist的优点；另外，每个ziplist的长度需要权衡。
   - skiplist：用于解决链表的查找效率问题，相当于用多层链表随机建立多层索引。
2. **Redis各数据类型对应实现**：
   - string：sds（long/raw/embstr）
   - list：ziplist/quicklist
   - hash：ziplist/dict
   - set：intset/dict
   - sortedset：skiplist
3. **内存回收**：Redis 在自己的对象系统中构建了一个引用计数（reference counting）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。
4. **键的过期策略**：定时删除、惰性删除 、定期删除。Redis采取惰性删除 + 定期删除。
5. **Redis数据持久化**：
   - 基于快照（rdb），定时生成快照，有遗漏的风险；
   - 保存所有写命令（aof），文件比较大。
6. **Redis是单线程的**：避免了线程上下文切换的问题；使用非阻塞的**I/O多路复用**机制，同时监听多个Socket。
7. **Redis的多机实现**：
   - 主从架构：主服务器负责接收写请求，从服务器负责接收读请求；首先从服务器发出SYNC命令，主服务器把所有的数据生成RDB复制到从服务器，后续通过**写命令传播**的方式将数据同步到从服务器。

   - 哨兵机制（Sentinel）：如果主服务器挂了，会从Sentinel中进行选举，把某一个从服务器升级为主服务器，原主服务器重连后成为从服务器。
8. **一致性哈希**：分表/使用集群时，把数据随机分配到各节点中的方法。对2^32取模，哈希值空间形成一个Hash环，然后将节点映射至环上。数据映射到环上后顺时针移动，第一个遇到的节点即是其应该定位到的节点。
9. **缓存雪崩**：因为缓存数据设置的过期时间相同，这些缓存同时失效，全部请求给到数据库，数据库很可能崩溃。缓存雪崩强调多个键同时失效。

   - 解决办法：给缓存过期时间加上一个随机值，避免缓存在同一时间过期；实现主从架构/哨兵机制。
10. **缓存穿透**：请求一个不存在的数据，缓存大量不命中，导致请求走数据库，给数据库很大压力。

    - 解决办法：使用布隆过滤器提前拦截不合法参数；把数据库找不到时返回的空对象也写到缓存中去。
11. **缓存击穿**：对于设置了过期时间的键可能会在某些时间点被高并发的访问。缓存击穿强调一个键。

    - 解决办法：在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。
12. **数据一致性**：主要针对更新/写操作。
    - 先更新数据库，再删除缓存：高并发下表现优异。
    - 先删除缓存，再更新数据库：两个操作的原子性被破坏时表现优异。
13. **CAP**：一个分布式系统最多只能同时满足CAP的两项。

    - Consistency：一致性，所有节点在同一时间的数据保持一致。

      - 强一致性：要求更新过的数据能被后续的访问都能看到。

      - 最终一致性：要求经过**一段时间后**能访问到更新后的数据。

    - Availability：可用性，服务在正常响应时间内一直可用。

    - Partition tolerance：分区容错性，一般在C和A之间权衡。

#### Redis分布式锁：

当我们有多个JVM实例在服务器端运行时，Java提供的原生锁机制会失效，所以我们要保证所有JVM实例用的同一个锁，即分布式锁。分布式锁和我们平常讲到的锁原理基本一样，目的就是确保在每个线程都要操作一个数据时，只有一个线程在同一刻操作这个数据。

setnx key value：Set if not exists，判断能否拿到锁，拿到则执行后续操作

del key：完成操作之后释放锁。

为了避免死锁，设置setnx key的过期时间。