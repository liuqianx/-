

## MySQL

### 事务

1. **事务**：事务包含一系列的操作，所有操作都必须完成，否则撤销回滚。
2. **事务的ACID特性**：
   
   - 原子性：要么都做，要么都不做。
   - 一致性：事务提交前后，数据库从一个正确的状态到另一个正确的状态，没有破坏数据库定义的一些约束条件。我们通过AID来保证数据库的一致性，保证在宏观上操作状态是正确的。
   - 隔离性：并发的事务之间不互相干扰，一个事务相对于其它并发事务是隔离的。
   - 持久性：事务完成后，事务对数据库的所有操作将被保存到数据库，不丢失。
3. **MySQL的四种隔离级别**：

   - 读取未提交内容：Read_Uncommited，有脏读。所有的事务都可以看到其他未提交事务的执行结果。
   - 读取提交内容：Read_Commited，有不可重复读。一个事务只能看到已经提交的事务做出的改变。
   - 可重复读：Repeated_Read，InnoDB默认的隔离级别，有幻读。在同一个事务内无论怎么读取**某一行**都是同一个结果。
   - 串行化：Serializable，通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。

4. **三个问题**：

   - 脏读：读出无效数据，即一个事务读取另一事务还没有提交的数据，另一事务可能**回滚**。

   - 不可重复读：在同一事务内的两次查询数据不一致，即读取了另一事务修改前和提交后的数据。

   - 幻读：是不可重复读的特殊场景，一个是单条数据，一个是多条数据；幻读指在同一事务内的两次操作返回的数据条数不一致（两次范围查询中间有其他事务插入数据到区间中）。

     > 可通过MVCC + Next-Key Locks解决。读方式有两种，执行简单的select的时候是快照读，其余操作是当前读，例如update操作。在快照上update数据是没有意义的，所以，MVCC不能根本上解决幻读的情况，我们还需要Next-Key Locks去同步读并修改最新的数据。Next-Key Locks可以锁住一个范围和记录本身。



### 索引

1. 索引本质是一种数据结构，主要是为了加快查询速度。

2. **Hash索引**：哈希表，只适用于等值查询的场景，不能范围查询。

3. **B+树索引**：

   - **特点**：一种多路平衡查找树，非叶子节点只进行索引，不保存实际的数据，所有的关键字记录都出现在叶子节点形成的链表中。
   - **优势**：相比于红黑树，高度远远小于红黑树，对于磁盘来说，每读一个节点对应着一次IO，所以相比之下B+树有**更少的IO次数**。B+树把同一内部节点的关键字索引项都放在同一盘块，一次性读入内存，可以对比的关键字就越多。
   - **优势**：相比于B-树，B+树查询效率更**稳定**；B+树的内部节点中的关键字并没有指向具体信息的指针，所以B+树的索引项更小，每个内部节点中包含的关键字就越多，查询效率也越高，相对的，**IO次数就会降低**；另外B+树叶子节点包含一个指向下一叶子节点的指针，**加快顺序存取**，遍历叶子节点就可以完成整棵树的遍历，而B-树需要遍历整棵树。

   <img src="https://imgedu.lagou.com/389a0147410142baab9eaac7b75747fe.jpg" alt="MySQL索引（二）B+树在磁盘中的存储" style="zoom:50%;" />

4. **聚簇索引**：聚簇索引的叶子节点同时也是数据节点，聚簇索引顺序和数据物理存放顺序一致。有且只有一个，主键所在的索引即为聚簇索引。

5. **辅助索引**：二级索引/普通索引，除了聚簇索引以外的索引。叶子节点存储有主键的值（InnoDB）/指向对应数据块的指针（MyISAM）。如果SQL查找条件为普通索引，则需要扫描两次B+树，即一次普通索引树，一次聚簇索引树。

   > 一张表一般包含一个聚集索引构成的B+树以及若干辅助索引的构成的B+树。

6. **覆盖索引**：覆盖索引指将普通索引建立到复合索引中去，由此只需要在一颗B+树上就能获得SQL所需的所有列数据。

7. **复合索引**：多个字段作为索引。

   - 最左前缀匹配：首先对复合索引最左边的字段进行排序。

> 可以使用explain命令来查看一条SQL语句是否使用了索引，组合索引的使用情况，需要扫描的总行数等。配合慢查询日志使用。



### 数据库锁：

**共享锁和排他锁**：即读锁/写锁。

**意向锁**：事务打算加行级读/写锁时，首先需要加意向锁。当一个表被上了行级锁时，意向锁避免了其他事务试图获取表级锁时扫描全表。

**表级锁**：开销小，加锁快，不会出现死锁；锁的粒度大，容易发生锁冲突。

**行级锁**：开销大，加锁慢，会出现**死锁**；锁的粒度小，并发度最高。

> MySQL查看和解除死锁：
>
> - ①查询当前是否有锁表；②查询进程；③杀死进程id。
>
> - ①查看当前锁定的事务；②杀死进程id。

**区间锁**：区间锁是锁定索引记录之间的区间。

**Next-Key Locks**：行级锁+区间锁。

**乐观锁**：需要自己实现，需要在数据表加上version字段，再在逻辑中使用CAS算法。

**悲观锁**：select ** for update

**AUTO-INC Locks**：由插入到具有 AUTO_INCREMENT 列的表中的事务所采用的特殊表级锁。

**MVCC**：Multiversion Concurrency Control，多版本并发控制

- 使用了一种与锁不同的手段来实现并发控制。为了让读写之间也不冲突，读取数据时通过类似快照的方式保存数据。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行。
- InnoDB为每行记录添加了一列版本号（系统版本号）。每当修改数据时，系统版本号加一。
- 在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号**小于等于**当前版本号的数据，就算另一个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。



### InnoDB与MyISAM的区别：

- InnoDB支持事务，MyISAM不支持。
- InnoDB隔离级别默认RR，MyISAM默认RC。
- InnoDB支持聚簇索引，MyISAM不支持，它的所有B+树索引的叶子节点保存的是数据文件的指针。
- InnoDB支持行锁，MyISAM不支持。
- InnoDB不支持全文索引，MyISAM支持。



### BinLog、RedoLog、UndoLog

- BinLog就是二进制日志，用于记录数据操作的日志。用于**主从复制和增量恢复**。

- RedoLog负责事务的重做，记录事务中的每一步操作，记录完再执行操作，并且在数据刷入磁盘前刷入磁盘，保证可以重做成功。因为事务提交后，数据可能没来得及写回磁盘就宕机时，在下次重新启动后能够成功恢复数据，保证事务的**持久性**。

- UndoLog负责事务的回滚，记录事务操作中的原值，记录完再执行操作，在事务提交前刷入磁盘，保证可以回滚成功。当发生错误或者需要回滚的事务能够成功回滚，保证事务的**原子性**。

  这两个日志也是实现分布式事务的基础。



### 切分：

**垂直切分**：将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分。

**水平切分**：将同一个表中的记录拆分到多个结构相同的表中。

- 数据分布策略：一致性哈希
- ID唯一性：UUID（无意义），雪花算法（64位：时间+datacenterId+workerId+毫秒内计数器）



## Redis

1. **Redis数据类型**：
   - **string**：sds（long/raw/embstr）
   - **list**：ziplist/quicklist
   - **hash**：ziplist/dict
   - **set**：intset/dict
   - **sortedset**：skiplist
2. **Redis底层数据结构**：
   - **RedisObject**：Redis的通用数据结构，Redis中的每一个对象都由一个RedisObject结构来表示。

   - **dict**：是一个哈希表，每个key/value对用dictEntry表示，key一般是一个string，value则是一个RedisObject。

     采用增量式重哈希，在需要扩容时避免一次性对所有的key进行重哈希，而是将重哈希操作分散到对于dict的各个增删改查的操作中去；每次对一小部分的key在ht[1]进行重哈希，触发扩容后将ht[1]复制到ht[0]再交换角色，有点Copy-on-write的意思。

   - **sds**：Simple Dynamic String，Redis的字符串结构，可动态扩展；如果是数字会转成long型储存。

     sds对象的编码可以是long/raw/embstr，字符串长度大于39用raw，小于用embstr。

   - **双向链表**

   - **ziplist**：是经过特殊编码的双向链表，各节点在内存上前后相邻；但是插入会发生realloc/内存拷贝。

     很类似数组，不同于数组的是ziplist每个元素所占的空间可变。

   - **quicklist**：一个双向链表，每个节点储存的都是一个ziplist；quicklist结合了双向链表和ziplist的优点。

   - **skiplist**：用于解决链表的查找效率问题，相当于用多层链表随机建立多层索引。

   - **intset**：结构上很像ziplist，但intset是有序的并且每个元素有统一的编码，对于大整数和小整数采取了不同的编码。
3. **键的过期策略**：定时删除、惰性删除 、定期删除。Redis采取定期删除 + 惰性删除 ，当使用定期删除，意味着会有一些过期key不能及时被删除，当读到过期的key时redis会进行惰性删除。
4. **Redis数据持久化**：
   - 基于快照（RDB），定时生成快照，有遗漏的风险；
   - 保存所有写命令（AOF），文件比较大。
5. **Redis是单线程的**：使用非阻塞的**I/O多路复用**机制，同时监听多个Socket；避免了线程上下文切换的消耗；没有锁的各种开销。
6. **Redis的集群实现**：
   - 主从架构：主服务器负责接收写请求，从服务器负责接收读请求；首先从服务器发出SYNC命令，主服务器把所有的数据生成RDB复制到从服务器，后续通过**写命令传播**的方式将数据同步到从服务器。
   - 哨兵机制（Sentinel）：如果主服务器挂了，会从Sentinel中进行选举，把某一个从服务器升级为主服务器，原主服务器重连后成为从服务器。raft协议
7. **一致性哈希**：分表/使用集群时，把数据随机分配到各节点中的方法。对2^32取模，哈希值空间形成一个Hash环，然后将节点映射至环上。数据映射到环上后顺时针移动，第一个遇到的节点即是其应该定位到的节点。
8. **缓存雪崩**：因为缓存数据设置的过期时间相同，这些缓存同时失效，全部请求给到数据库，数据库很可能崩溃。缓存雪崩强调多个键同时失效。
   
   - 解决办法：给缓存过期时间加上一个随机值，避免缓存在同一时间过期；实现主从架构/哨兵机制。
9. **缓存穿透**：请求一个不存在的数据，缓存大量不命中，导致请求走数据库，给数据库很大压力。

   - 解决办法：使用布隆过滤器提前拦截不合法参数；把数据库找不到时返回的空对象也写到缓存中去。
10. **缓存击穿**：对于设置了过期时间的键可能会在某些时间点被高并发的访问。缓存击穿强调一个键。

    - 解决办法：缓存失效时，在访问数据库之前，采用SETNX（set if not exists）来设置另一个短期key来锁住对redis当前key的访问，写入该key到缓存之后再删除该短期key。
11. **缓存与数据库的双写一致性**：主要针对更新/写操作。
    - 先更新数据库，再删除缓存：缓存中会短时间内存在旧数据。
    - 先删除缓存，再更新数据库：即Cache Aside Pattern，redis可能会读到脏数据，延迟双删。
12. **CAP**：一个分布式系统最多只能同时满足CAP的两项。当要保证强一致性的时候，就必定会让服务不可用一段时间，然后在这期间通过一致性算法达到一致；当要保证强可用性的时候，即保证服务一直可用，那么就无法达到强一致性。
    - Consistency：一致性，所有节点在同一时间的数据保持一致。
      - 强一致性：要求更新过的数据能被后续的访问都能看到。
      - 最终一致性：要求经过**一段时间后**能访问到更新后的数据。
    - Availability：可用性，服务在正常响应时间内一直可用。
    - Partition tolerance：分区容错性，数据分布在各节点，某个节点宕机，仍然能够提供服务。
13. **BASE**：基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）。BASE牺牲高一致性，获得可用性或可靠性



#### Redis分布式锁：

当我们有多个JVM实例在服务器端运行时，Java提供的原生锁机制会失效，所以我们要保证所有JVM实例用的同一个锁，即分布式锁。分布式锁和我们平常讲到的锁原理基本一样，目的就是确保在每个线程都要操作一个数据时，只有一个线程在同一刻操作这个数据。

setnx key value：Set if not exists，判断能否拿到锁，拿到则执行后续操作

del key：完成操作之后释放锁。

为了避免死锁，设置setnx key的过期时间。



#### Redis集群实战：

1. Redis集群需要至少6个节点，3主3从。

2. Redis集群没有使用一致性哈希，而是引入了哈希槽的概念；

   使用CRC16算法将数据散列到16384个哈希槽中，集群中的每个master负责一部分哈希槽。使用哈希槽的好处就在于可以方便的添加或移除节点。

3. 读写分离，Master只负责写命令和同步数据到slaves， Slave负责读命令。

   通过增加Master可以提高并发写的能力，增加Slave可以提高并发读的能力。

<img src="http://inews.gtimg.com/newsapp_bt/0/5348364383/1000/0" alt="img" style="zoom: 67%;" />