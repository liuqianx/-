# 高并发秒杀系统

## 1. 流程

1. 前端请求一个商品详情页，如果缓存中存在就从缓存中取；

2. 前端用../{productId}/exposer请求商品购买的接口 ；

3. 后端比较现在的时间和商品秒杀的时间，如果到了时间则用ID生成一串md5返回，否则返回秒杀时间，封装成一个Exposer类对象（DTO）返回给前端；

4. 若前端得到了md5，则可以对../{productId}/{md5}/execute发起购买请求；

6. 在减库存之前加一个Redis分布式锁（setnx）；

7. 对数据库商品减库存的时候再次进行判断时间/库存是否足够 ；

8. 失败则返回原因提示，封装成一个OrderExecutionState类对象（DTO）返回 。

   成功则将一条订单写入redis消息队列，异步插入数据库。（同时删除缓存中的这条商品数据来实现一致性）

9. 对库存数解锁。

10. 结束。



## 2. 同步控制

#### 多线程减库存的实现：

1. 用synchronized保证代码同步：不可行，synchronized只作用于单个jvm实例，如果有分布式集群则失效。单个jvm时也无法保证，与代码中的事务传播级别，数据库的事务隔离级别，加锁时机等相关。
2. 不查询直接更新：不具备通用性。
3. CAS：要加上版本号，数据库的事务隔离级别必须是RC。
4. 使用数据库锁：select xx for update，悲观锁。
5. 使用分布式锁：zookeeper、redis等。



## 3. 优化

#### 高并发优化：

1. 对于前端控制：按钮防重复、按钮在秒杀开始前置黑

2. 对于后端缓存：使用Redis缓存序列化product、接口地址

3. 对于通信过程：使用消息队列

4. 对于秒杀操作：

   - 使用存储过程：把减库存+建立订单整个事务在MySQL端完成，没有通用性。

   - 定制SQL：修改MySQL源码，不推荐。

#### Redis的具体使用：

1. 商品列表放入Redis List
2. 商品的详情数据序列化后保存在Redis，设置过期时间
3. 扣库存通过Redis setnx制造分布式锁，库存同步扣除
4. 订单产生后发货的数据，通过消息队列处理
   - 利用list的LPUSH + BRPOP实现生产者/消费者模式
   - 利用channel实现发布/订阅模式

#### 系统架构部署优化：

1. 动静态资源分离：CDN
2. 集群：Nginx负载均衡
3. 服务器缓存：Redis
4. 数据库
5. 消息队列



## 4. 学习到的杂项

1. DTO类的使用
2. 定义多个Exception异常对象
3. enums枚举类的使用
4. Redis分布式锁
5. 使用@Transactional定义事务
6. 使用MD5暴露接口
7. Restful接口：/模块/资源/{标识}/操作





