# 高并发秒杀系统

## 1. 流程

1. 前端请求一个商品详情页，如果缓存中存在就从缓存中取；

2. 前端用../{productId}/exposer请求商品购买的接口 ；

3. 后端比较现在的时间和商品秒杀的时间，如果到了时间则用ID生成一串md5返回，否则返回秒杀时间，封装成一个Exposer类对象（DTO）返回给前端；

4. 若前端得到了md5，则可以对../{productId}/{md5}/execute发起购买请求；

6. 在减库存之前加一个Redis分布式锁（setnx）；

7. 对数据库商品减库存的时候再次进行判断时间/库存是否足够 ；

8. 失败则返回原因提示，封装成一个OrderExecutionState类对象（DTO）返回 。

   成功则将一条订单写入redis消息队列，异步插入数据库。（同时删除缓存中的这条商品数据来实现一致性）

9. 对库存数解锁。

10. 结束。



## 2. 超卖问题

#### 多线程减库存的实现：

1. 用synchronized保证代码同步：不可行，synchronized只作用于单个jvm实例，如果有分布式集群则失效。单个jvm时也无法保证，与代码中的事务传播级别，数据库的事务隔离级别，加锁时机等相关。
2. 不查询直接更新：不具备通用性。
3. 使用数据库乐观锁：CAS，要加上版本号，数据库的事务隔离级别必须是RC。
4. 使用数据库悲观锁：select xx for update。
5. 使用分布式锁：zookeeper、redis等。怎么都会有排队的问题：可以把库存分成几个部分，分段锁不同的部分来同步减库存。有点ConcurrrentHashMap的思想。



## 3. 双写一致性问题

Cache Aside Pattern

一开始写进商品详情数据至redis

每次读 ——> 首先检查redis中是否存在 ——> 存在则直接返回，否则从数据库读，并写入redis。

每次写 ——> 先删缓存，再写数据库 ——> 有可能在这期间另一线程把脏数据写入到缓存 

- 延时双删：写到数据库后延迟1秒再次删除缓存（可以异步）。
- 读请求和写请求串行化，串到一个内存队列里去。



## 4. 优化

#### 高并发优化：

1. 对于前端控制：按钮防重复、按钮在秒杀开始前置黑

2. 对于后端缓存：使用Redis缓存序列化product、接口地址

3. 对于通信过程：使用消息队列

4. 对于秒杀操作：

   - 使用存储过程：把减库存+建立订单整个事务在MySQL端完成，没有通用性。

   - 定制SQL：修改MySQL源码，不推荐。

#### 系统架构部署优化：

1. 动静态资源分离：CDN
2. 集群：Nginx负载均衡
3. 服务器缓存：Redis
4. 数据库
5. 消息队列



## 5. 学习到的杂项

1. DTO类的使用
2. 定义多个Exception异常对象
3. enums枚举类的使用
4. Redis分布式锁
5. 使用@Transactional定义事务
6. 使用MD5暴露接口
7. Restful接口：/模块/资源/{标识}/集合





