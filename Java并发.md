# Java并发

## 1. 基础

1. **并发/并行**：并发是多个线程轮流使用CPU的一个核，并行是多个线程同时使用CPU的多个核。
2. **同步/异步**：用来描述被调用方。在调用方发出请求后，该调用是否立马返回。
3. **阻塞/非阻塞**：用来描述调用方。在调用返回之前，调用方的当前线程是否挂起。
4. **线程间的通信方式**：共享内存、锁机制、信号量、wait/notify。
5. **进程间的通信方式**：消息队列、Socket、管道、信号、信号量、共享内存。
6. **线程/进程**：进程是系统分配资源的基本单位，线程是调度CPU的基本单位。
7. JVM中多个线程共享进程的堆和方法区资源。
8. JVM中每个线程都有自己的程序计数器、虚拟机栈、本地方法栈。
9. **协程**：协程运行在线程中，协程没有线程的上下文切换消耗，有原子操作性。例：Java的Foreach迭代器。
10. **创建线程的三种方式**：继承Thread类（实际上实现了Runnable接口）、实现Runnable、实现Callable。
11. **Thread和Runnable**：Thread是多个线程分别完成自己的任务，Runnable是多个线程共同完成一个任务。Runnable可以很容易的实现资源共享。
12. **Runnable和Callable**：功能相似，Callable的call()函数有返回值，而Runnable的run()函数没有。
13. **线程的6种状态**：NEW、RUNNABLE、BLOCKED、WAITING、TIME_WATING、TERMINATED
14. **start()和run()**：start()是Thread类用来异步启动线程的一个方法，主线程立刻返回，该启动的线程不会马上运行，会放到等待队列中等待CPU调度，只有线程被真正调度时才会调用run()方法执行。
15. **wait()和sleep()**：sleep()让正在执行的线程让出CPU，但不会释放锁；wait()是指当前线程暂时释放资源锁，当调用了notify()或者wait时间到了时线程被唤醒，可以去参加锁的竞争。wait()只能在同步方法或同步块中使用。
16. **join()**：表示当前线程等待这个线程结束后才可继续。主线程调用t.join()时，主线程进入阻塞状态，只有当线程t结束了，才会进入可运行状态。
17. **yield()**：Thread类的方法，使一个线程让出CPU，让一个running状态的线程转入runnable。

   <img src="https://img-blog.csdn.net/20150309140927553" alt="img" style="zoom:90%;" /> 

11. **线程安全**：一个方法或者一个实例对象（资源）可以在多线程环境中使用而不会出现问题。

12. **Happens-Before原则**：用来判断是否线程安全。

15. **实现线程安全的三种方式**：

    - 使对象不可变。
    - 不在线程中共享对象。
    - 对对象使用同步机制，使其具有原子性。但同步机制会带来一定的串行化。

17. **Java同步机制**：

    - Synchronized关键字：即Java内置锁，可以锁住一个对象/方法/代码块。
    - Lock接口实现类：API级别的自旋锁，比Synchronized更灵活，AQS实现。
    - Semaphore/CountDownLatch/CyclicBarrier/Phaser：信号量，AQS实现。
    - Atomic：原子变量，是粒度最细的锁，使用CAS算法，不需要挂起和重新调度线程。
    - Volatile：特殊，保证可见性和有序性，不保证原子性。

    > 线程同步的目的是为了防止多个线程访问同一个资源时对资源的破坏。
    >
    > 对于同步，要时刻清醒在哪个对象上同步。每个对象都有且仅有一个锁。

18. **并发出现的问题**：原子性问题，可见性问题，有序性问题。

18. **JUC**：java.util.concurrent包，提供了大量工具帮助编写多线程程序。

19. **Synchronized关键字**：保证线程之间访问资源的同步性。可修饰实例方法、静态方法、代码块、类。

20. **Volatile关键字**：保证可见性（数据在寄存器与主存中的值不一致），防止指令的重排序，但不保证原子性。只能用于变量。

    > 例如多线程进行count++，即使使用volatile修饰count，保证了每次获取到的值是最新的，但由于volatile不能保证原子性，即count++这个操作涉及到的获取值、自增、赋值操作不能同时完成，所以count++仍然可能得到错误的结果。

21. **ThreadLocal**：每个访问该变量的线程都会有一份该变量的本地副本，互不影响。

    - 每个Thread对象都持有一个TreadLocalMap类型的对象，它包含多个Entry/K-V对象，key是ThreadLocal对象本身，value是要存储的对象。（ThreadLocal本身并不储存值，而是作为key来获取value）
    - 内存泄漏：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏。

22. **CAS**：Compare and Swap，线程在更新数据之前先比较原数据是否变化，如果没有变化则更新数据。

    > ABA问题：线程1读取值为A的变量；此时线程2读取并修改该变量为B，再修改成A；此时线程1进行修改操作，并不知晓该变量已经发生了变化。解决办法：每次变量更新都加上版本号。

23. **Atomic**：原子类，当多个线程一起执行，一个原子操作一旦开始就不会被其他线程干扰。主要使用了CAS算法 + native + volatile方法来保证原子性，避免synchronized的高开销。

24. **AQS**：AbstractQueuedSynchronizer，用来构建锁和同步器的框架。

    - AQS定义了两种资源共享的方式：独占（ReentrantLock）、共享（CountDownLatch/CyclicBarrier）。

    - AQS对象有两个核心变量：state变量代表了加锁的状态；另一个变量记录当前拿到锁的线程。
    - ReentrantLock加锁的过程其实就是用CAS将state值加1。
    - 试图获得锁失败的线程会进入AQS的一个阻塞队列（双向链表）。等待队列通过volatile修饰，保证多线程之间的可见性。

23. **CountdownLatch**：同步辅助工具类，用于一个线程等待一组其它线程执行完毕。（一等多）

    - await()方法：调用这个方法的线程会被阻塞。
    - countdown()方法：调用这个方法会使计数器减一，当计数器的值为0时，因调用await()方法被阻塞的线程会被唤醒，继续执行。

24. **CyclicBarrier**：同步辅助工具类，用于一组线程间相互等待至某同步点。（互相等）

25. **ThreadPool**：线程池，预先启动若干数量的线程，并让这些线程都处于睡眠状态，当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程来处理请求。可以通过ThreadPoolExecutor来创建。 

    - 提交一个任务给线程池，在核心线程没满时，创建一个**核心线程**处理任务，否则放入一个**阻塞队列**中等待；如果阻塞队列也满了，则会创建一个**非核心线程**处理任务；如果达到了线程池规定的最大线程数，直接采用**拒绝策略**。（最大线程数 = 核心线程数 + 非核心线程数）

26. **分布式锁**：当我们有多个JVM实例在服务器端运行时，Java提供的原生锁机制会失效，所以我们要保证所有JVM实例用的同一个锁，即分布式锁。



## 2. Java 内存模型

1. JMM是一个抽象的概念，描述了一组规范，JMM规范了JVM与计算机内存之间是如何协同工作的：规定了一个线程如何/何时可以看到由其他线程修改过后的共享变量的值，以及在需要时如何同步的访问共享变量。

2. Java的多线程之间是**通过共享内存进行通信**的，而由于采用共享内存进行通信，在通信过程中会存在一系列问题，而JMM就是围绕着多线程通信以及与其相关的一系列特性（可见性、原子性、有序性）而建立的模型。JMM定义了一些语法集，这些语法集**映射**到Java语言中就是volatile、synchronized等关键字。

3. **Java线程间的通信**：首先线程A把工作内存中更新过的共享变量刷新到主内存中，然后线程B到主内存中读取线程A更新的共享变量。

4. 为了实现主内存与工作内存的具体交互，JMM定义了8种操作。

   - lock、unlock、read、load、use、assign、store、write

   <img src="https://img-blog.csdn.net/20180522220730109" alt="img" style="zoom:60%;" />

5. **可见性**：某个线程修改共享变量，其他线程能够看到（所有线程的工作内存和主内存的共享变量值与之同步）。可以通过声明final/volatile/synchronized实现可见性。若未声明，可能导致每个线程的工作内存都拥有这个共享变量的私有拷贝。

6. **有序性**：CPU会对程序指令进行重排序，重排序后依然可以保证线程内的代码依语义顺序执行，但会使得并发的线程间乱序执行非同步的代码，即多线程程序的语义会被打破（变量在线程间存在的关联关系会被重排序打乱）。volatile/synchronized可维持某块代码相对有序。

7. **原子性**：一个操作或者多个操作要么全部执行，要么不执行。多个线程同时在共享对象上更新变量，可以用原子方式执行操作，同步块技术。

8. **内存屏障**：Java通过内存屏障保证底层操作的有序性和可见性。

9. **volatile关键字语义**：
   
   - 保证可见性
   - 保证有序性：禁止进行指令重排序




## 3. 锁的分类

悲观锁和乐观锁不特指某个锁，而是并发情况下的两种不同策略。悲观锁阻塞事务，乐观锁回滚重试。

**悲观锁**：每次线程拿数据时都认为数据会被修改，所以每次线程拿数据的时候都会给数据上锁。用于多写。

**乐观锁**：每次线程拿数据时都认为数据不会被修改，所以不会上锁。但是如果线程想要更新数据，则会检查读取到更新这段时间内这个数据有没有被修改；如果修改过则再次读取尝试更新，直到更新成功。用于多读。

- java.util.concurrent.atomic包里面的原子类都是利用乐观锁实现。

- CAS：Compare and Swap，线程在更新数据之前先比较原数据是否变化，如果没有变化则更新数据。

**公平锁**：当锁被释放时，先申请的先得到锁。

**非公平锁**：当锁被释放时，后申请的线程可能先得到。默认采用非公平锁，因为非公平锁的吞吐量比较大。

**可中断锁**：线程A可以向线程B（或者线程B向自己）发出中断请求，线程B可以在合适时机响应中断，或直接忽略这个请求。在Java中，synchronized是不可中断锁，而Lock的实现类都是可中断锁。



## 4. Java加锁方式

**Java有两种加锁的方式**：Synchronized关键字、Lock接口的实现类。

ReentrantLock、ReadLock、WriteLock是Lock接口中最重要的三个实现类。

<img src="https://pic1.zhimg.com/v2-ddb71ab0b68d65ae70244bfdeb0d6704_r.jpg" alt="preview" style="zoom: 43%;" />

#### Synchronized关键字

Synchronized的锁升级：无锁 ——> 偏向锁 ——> 轻量级锁 ——> 重量级锁

偏向锁：初次执行到Synchronized代码块时，对象从无锁变成偏向锁（修改对象头里的锁标志位）。在执行完同步代码后，线程**不会主动释放**偏向锁。当同一线程第二次执行到同步代码块时，由于之前没有释放锁，所以也就不需要重新加锁。如果自始至终都只有一个线程在使用锁，则偏向锁相当于没有额外的开销，性能很高。

轻量级锁：当有第二个线程B尝试获取锁时，发现是偏向锁，会先判断拥有偏向锁的线程A是否仍然存在；如果A仍然存在，则偏向锁升级为轻量级锁（自旋锁），否则线程B获得这个偏向锁，锁不升级。没有抢到轻量锁的线程将**自旋/忙等**，即不停的循环判断锁能否被成功获取（对象头里的锁标志位是否为”释放“）。

重量级锁：如果锁竞争严重，当某个线程自旋超过10次（可通过JVM修改），会将轻量级锁升级为重量级锁，即修改对象的锁标志位。当后续线程尝试获取锁失败时，就会直接把自己**挂起**，等待将来被唤醒，而不是忙等。

#### Lock接口的实现类

ReentrantLock：可重入锁/递归锁，允许同一个线程多次获取同一把锁，即含加锁操作的递归函数在过程中不会阻塞自己。ReentrantLock是互斥锁。JDK提供的所有现成的Lock实现类、synchronized关键字锁都是可重入的。

ReentrantReadWriteLock：读写锁，其实是一对锁：读锁/共享锁、写锁/互斥锁。读写锁有点类似乐观锁，但是是悲观锁策略，因为它在加锁前就决定了用读锁还是写锁，而不是在更新数据前进行判断。

#### Synchronized和Lock接口的实现类比较

相似点：

- 两者都是可重入锁；都是以加锁方式实现同步，而且都是阻塞式的同步。

不同点：

- synchronized是关键字，依赖于JVM来实现；Lock是API层面提供的锁，需要lock/unlock配合try/finally完成。
- synchronized是不可中断锁；而Lock的实现类都是可中断锁。
- synchronized是非公平锁；Lock默认是非公平锁，但可以通过构造函数要求使用公平锁。
