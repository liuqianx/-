# Linux相关

## 1. linux的网络IO模型

1. **文件描述符**：在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件、设备文件、socket。文件描述符是内核为了高效管理已被打开的文件所创建的**索引**，它是一个非负整数，用于指代被打开的文件，所有执行I/O操作（包括网络socket操作）的系统调用都通过文件描述符。

2. **内核态和用户态**：操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，linux将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
3. **recvfrom()调用**：用来接收远程主机经指定的socket 传来的数据。

### IO模型

对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说包含了两个阶段：

- 等待数据拷贝至内核 （区别在这里）
- 将数据从内核拷贝到进程（同步IO在这个拷贝过程中都阻塞）

因为这两个阶段，linux系统产生了5种网络IO模型：

- 阻塞I/O：两个阶段都被block
- 非阻塞I/O：用户进程不断的主动询问kernel数据准备好了没有。
- I/O多路复用：通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。
- 异步I/O：用户进程发起read操作之后，立刻就可以开始去做其它的事。
- 信号驱动I/O

### 多路复用之select、poll、epoll

elect，poll，epoll都是IO多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。他们的本质都是同步IO，因为在读写事件准备就绪之后自己负责读写数据到用户空间，也就是说这个过程是阻塞的，而异步I/O则无需自己负责进行读写。

拿读来举例，首先我们读的数据来自硬件设备（硬盘、网卡），在linux中，我们把这些可读写的设备都看作文件，用一个fd（文件描述符）来标识。

只有内核空间有资格对这些设备进行访问，所以一个用户进程的IO访问包括两个步骤：内核把这些设备里的数据拷贝至内核空间（所谓的fd就绪），进程再把数据从内核空间拷贝到用户空间。

多路复用机制下，在第二个阶段是阻塞的，但在第一个阶段是非阻塞的。select、poll、epoll就代表了在第一阶段如何选择就绪fd的方法。

- **select**中把所有需要监视的fd/socket都放在一个**数组**里，每次调用select()时遍历fd从而找到就绪的fd集合，然后select唤醒进程进行处理。因为是数组，所以有上限。

- **poll**中把所有需要监视的fd/socket都放在一个**链表**里，每次调用poll()时遍历fd从而找到就绪的fd集合，然后poll唤醒进程进行处理。

- **epoll**中只需维持一个**Ready队列**，每当有fd/socket准备就绪时会调用**回调函数**，插入到Ready队列之中。epoll使用epoll_wait来轮询Ready队列然后唤醒进程进行处理。
  - **水平触发**：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，进程可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。
  - **边缘触发**：当epoll_wait检测到某描述符事件就绪并通知应用程序时，进程必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。所以程序要写的很细致。

![img](https://img-blog.csdnimg.cn/20190111184024145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70)



## 2. linux常用命令

1. ps：显示系统的运行进程。
2. top：默认按照CPU的占用情况，显示占用量较大的进程。
3. grep：在给定的文件中正则匹配。
4. cat：用于在标准输出（监控器或屏幕）上查看文件内容。
5. chmod：用于改变文件和目录的权限。
6. ifconfig：用于查看和配置Linux系统的网络接口。
7. netstat：查看端口状态



## 3. 死锁

死锁的四个必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 占有且等待：因请求资源而阻塞的进程不释放已获得的资源。
3. 不可强行占有：不能强行剥夺其他进程已获得的资源。
4. 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。

死锁的预防：破坏上述四个条件

死锁的避免：进程启动拒绝、资源分配拒绝

死锁的解除：撤销进程、剥夺资源