# Linux相关

## 1. linux的网络IO模型

1. **文件描述符**：在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件、设备文件、socket。文件描述符是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数，用于指代被打开的文件，所有执行I/O操作（包括网络socket操作）的系统调用都通过文件描述符。

2. **内核态和用户态**：操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，linux将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
3. **recvfrom()调用**：用来接收远程主机经指定的socket 传来的数据。

### IO模型

对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说包含了两个阶段：

- 等待数据拷贝至内核 
- 将数据从内核拷贝到进程（同步IO由用户进程执行这个拷贝过程）

因为这两个阶段，linux系统产生了5种网络IO模型：

- 阻塞I/O：两个阶段都被block
- 非阻塞I/O：用户进程不断的主动询问kernel数据准备好了没有。
- I/O多路复用：通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。
- 信号驱动I/O
- 异步I/O：用户进程发起read操作之后，开始去做其它的事，等内核做完这两步之后才通知用户进程。

### 多路复用之select、poll、epoll

select，poll，epoll都是实现IO多路复用的机制。I/O多路复用就是通过一种机制，使一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。他们的本质都是同步IO，因为在读写事件准备就绪之后自己负责读写数据到用户空间，也就是说这个过程是阻塞的，而异步I/O则无需自己负责进行读写。

拿读来举例，首先我们读的数据来自硬件设备（硬盘、网卡），在linux中，我们把这些可读写的设备都看作文件，用一个fd（文件描述符）来标识。

只有内核空间有资格对这些设备进行访问，所以一个用户进程的IO访问包括两个步骤：内核把这些设备里的数据拷贝至内核空间（所谓的fd就绪），进程再把数据从内核空间拷贝到用户空间。

多路复用机制下，在第二个阶段都是阻塞的，但在第一个阶段是非阻塞的。select、poll、epoll就代表了在第一阶段如何选择就绪fd的方法。

- **select**中把所有需要监视的fd/socket都放在一个**数组**里，每次调用select()时遍历fd从而找到就绪的fd集合，然后select唤醒进程进行处理。因为是数组，所以有上限。

- **poll**中把所有需要监视的fd/socket都放在一个**链表**里，每次调用poll()时遍历fd从而找到就绪的fd集合，然后poll唤醒进程进行处理。

- **epoll**中只需维持一个**Ready队列**，每当有fd/socket准备就绪时会触发IO事件，调用**回调函数**，插入到Ready队列之中。epoll只需使用epoll_wait来轮询Ready队列然后唤醒进程进行处理。
  - **水平触发**：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，进程可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。
  - **边缘触发**：当epoll_wait检测到某描述符事件就绪并通知应用程序时，进程必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。所以程序要写的很细致。

![img](https://img-blog.csdnimg.cn/20190111184024145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70)



## 2. linux常用命令

1. ps：显示系统的运行进程。
2. top：默认按照CPU的占用情况，显示占用量较大的进程。
3. free：系统使用内存的情况。
4. grep：在给定的文件中正则匹配。
5. cat：用于在标准输出（监控器或屏幕）上查看文件内容。
6. chmod：用于改变文件和目录的权限。
7. ifconfig：用于查看和配置Linux系统的网络接口。
8. netstat：查看tcp/udp端口状态。



## 3. fork()函数

调用fork()函数，就产生子进程，原来的进程叫父进程。这个子进程也是进程，但凡是进程，都有自己的虚拟地址空间。虚拟地址空间是从0到4G的大小，其中3-4G是属于内核的。

创建完子进程后，父进程继续运行原来的进程的代码，刚创建出来的子进程拥有和父进程**完全一样**的代码段，数据段，也就是说完完全全拷贝了一份父进程，和父进程完全一样。即clone父进程0-3G的内容，而3-4G的kernel只需要重新映射一下到物理地址的kernel即可。

fork()完以后，父进程和子进程由于有着同样的数据段和代码段，栈，PCB也大部分相同，所以两个进程就会干着同样的事情，这样对我们没有意义，所以需要**识别**哪个是父进程，哪个是子进程，然后让父进程接着干原来的事，子进程去干**新的事情**。

但是操作系统要如何区分这两个进程呢？答案就是**进程ID**，即pid。pid是存储在PCB当中的类似身份证的东西。子进程会clone父进程的PCB到子进程，但是PCB里的pid会从操作系统中获取，得到新的pid。

getpid()返回的是当前进程的pid,getppid()返回的是当前进程的父进程的pid。



## 4. 进程间的通信方式

1. **匿名管道（Pipe）**：在内核中开辟一块缓冲区用于通信，两个进程通过一个管道只能实现单向通信。只能用于具有亲缘关系的进程间通信，例如父子，兄弟进程。

2. **有名管道（FIFO）**：FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储文件系统中。命名管道是一个存在于硬盘上的文件，而管道是存在于内存中的特殊文件。命名管道是一个设备文件，因此即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。

3. **消息队列**：进程把数据写到内存后就直接返回。
4. **共享内存**：两个进程各自划分出一块虚拟内存区域，然后映射到同一物理内存块中。无需数据拷贝。因为共享内存没有提供相应的互斥机制，所以一般共享内存都和信号量配合起来使用。
5. **信号量**：信号量的本质是一种数据操作锁，用来实现进程之间的互斥与同步。
6. **socket**：套接字给予运行在不同主机的进程进行通信的能力，需要TCP/UDP的支持。



## 5. 进程调度算法

线程有两种调度模型：分时调度模型和抢占式调度模型。

1. 先来先服务算法：FCFS，从就绪队列中选择一个最先进入该队列的进程，分配CPU。
2. 短作业(进程)优先调度算法：从就绪队列中选出一个估计运行时间最短的进程。
3. 时间片轮转法：让每个进程轮流执行一段时间。
4. 最高响应比优先：R=(w+s)/s，其中R是响应比，w是等待处理器的时间，s是期待的服务时间。
5. 抢占式：优先让可运行池中优先级高的线程占用CPU。



## 6. 死锁

**死锁的四个必要条件**：

1. 互斥：一个资源每次只能被一个进程使用。
2. 占有且等待：因请求资源而阻塞的进程不释放已获得的资源。
3. 不剥夺：不能强行剥夺其他进程已获得的资源。
4. 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。

**死锁的预防**：破坏上述四个条件

- 破坏占有且等待条件，给锁加上一个超时时间，超时则放弃资源，然后等待一段随机的时间再重试。

- 破坏循环等待条件，通过控制加锁的**时序**预防死锁，常用。

**死锁的避免**：进程启动拒绝、资源分配拒绝

- 安全状态：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然**存在某种调度次序**能够使得每一个进程运行完毕，则称该状态是安全的。安全状态的检测与死锁的检测类似。
- 银行家算法：拒绝会导致不安全状态的进程的资源请求。

**死锁的检测**：每当一个线程获得锁，用一个数据结构（图）记下，再用死锁检测算法（检测环）检测死锁。

**死锁的解除**：撤销进程、剥夺资源

