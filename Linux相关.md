# 操作系统相关

## 1. linux的网络IO模型

1. **文件描述符**：在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件、设备文件、socket。文件描述符是内核为了高效管理已被打开的文件所创建的索引，它是一个非负整数，用于指代被打开的文件，所有执行I/O操作（包括网络socket操作）的系统调用都通过文件描述符。

2. **内核态和用户态**：操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，linux将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。

### IO模型

对于一次IO访问（以read举例），包含了两个阶段：

- 内核将数据从文件拷贝至内核缓冲区
- 将数据从内核缓冲区拷贝到用户进程空间（同步IO由用户进程执行这个拷贝过程，异步IO由内核来执行）

因为这两个阶段，linux系统产生了5种网络IO模型：

- 阻塞I/O：阻塞等待内核数据返回。
- 非阻塞I/O：用户进程定期主动询问数据准备好了没有。
- I/O多路复用：通过一种机制一个进程能同时等待多个文件描述符，把询问的过程交给了内核，当这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select函数就可以返回。
- 信号驱动I/O
- 异步I/O：用户进程发起read操作之后，开始去做其它的事，等内核做完这两步之后才通知用户进程。

### 多路复用之select、poll、epoll

select，poll，epoll都是实现IO多路复用的机制。I/O多路复用就是通过一种机制，使一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

拿读来举例，我们把文件/socket用一个fd（文件描述符）来标识。

多路复用机制下，IO的第一个阶段是非阻塞的。select、poll、epoll就代表了在第一阶段如何选择就绪fd的方法。

- **select**：内核把所有需要监视的fd都放在一个**数组**里，每次调用select()时遍历数组从而找到就绪的fd集合，然后select唤醒进程进行处理。因为是数组，所以有上限。

- **poll**：内核把所有需要监视的fd都放在一个**链表**里，每次调用poll()时遍历链表从而找到就绪的fd集合，然后poll唤醒进程进行处理。

- **epoll**：内核只需维持一个**Ready队列**，每当有fd准备就绪时会触发IO事件，调用**回调函数**插入就绪的fd到Ready队列之中。epoll只需使用epoll_wait来轮询Ready队列然后唤醒进程进行处理。
  - **水平触发**：默认工作模式，即当epoll_wait检测到某描述符事件就绪并通知应用程序时，进程可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。
  - **边缘触发**：当epoll_wait检测到某描述符事件就绪并通知应用程序时，进程必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。所以程序要写的很细致。

![img](https://img-blog.csdnimg.cn/20190111184024145.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3BhbmdlMTk5MQ==,size_16,color_FFFFFF,t_70)



## 2. linux常用命令

1. ps：显示系统的运行进程。
2. top：默认按照CPU的占用情况，显示占用量较大的进程。
3. free：系统使用内存的情况。
4. ifconfig：用于查看和配置Linux系统的网络接口。
5. netstat：查看tcp/udp端口状态。
6. grep：在给定的文件中正则匹配。
7. cat：用于在标准输出（监控器或屏幕）上查看文件内容。
8. chmod：用于改变文件和目录的权限。



## 3. fork()函数

调用fork()函数，就产生子进程，原来的进程叫父进程。这个子进程也是进程，但凡是进程，都有自己的虚拟地址空间。虚拟地址空间是从0到4G的大小，其中的3-4G是属于内核的。

创建完子进程后，父进程继续运行原来的进程的代码，刚创建出来的子进程拥有和父进程**完全一样**的代码段，数据段，也就是说完完全全拷贝了一份父进程，既然是副本，也就是说两者并不共享地址空间，但是父子进程共享文件表项，共同操作同一个文件表。即clone父进程0-3G的内容，而3-4G的kernel只需要重新映射一下到物理地址的kernel即可。

fork()完以后，父进程和子进程由于有着同样的数据段和代码段，栈，PCB也大部分相同，所以两个进程就会干着同样的事情，这样对我们没有意义，所以需要**识别**哪个是父进程，哪个是子进程，然后让父进程接着干原来的事，子进程去干**新的事情**。

操作系统利用**进程ID**来区分这两个进程，即pid，pid存储在PCB当中。子进程会clone父进程的PCB到子进程，但是PCB里的pid会从操作系统中获取到新的pid。

getpid()返回的是当前进程的pid,getppid()返回的是当前进程的父进程的pid。



## 4. 进程间的通信方式

1. **匿名管道（Pipe）**：在内存中开辟一块**缓冲区**用于通信，两个进程通过一个管道只能实现单向通信。只能用于具有亲缘关系的进程间通信，例如父子，兄弟进程。
2. **有名管道（FIFO）**：FIFO提供了一个路径名与之关联，以FIFO的**文件**形式存储文件系统中。命名管道是一个存在于硬盘上的文件，一个设备文件，因此即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。
3. **消息队列**：内核把发送方的消息写到一个**消息缓冲区**，再把消息复制给接收进程。
4. **共享内存**：两个进程各自划分出一块**虚拟内存**区域，然后映射到同一物理内存块中，无需数据拷贝。因为共享内存没有提供相应的同步机制，所以一般共享内存都和信号量配合起来使用。
5. **信号量**：信号量的本质是一种数据操作锁，用来实现进程之间的互斥与同步。
6. **socket**：套接字给予运行在不同主机的进程进行通信的能力，需要TCP/UDP的支持。
7. **信号**：当有特定事件发生时发出信号通知进程。



## 5. 进程调度算法

进程有CPU型进程和IO型进程。

#### 批处理系统：目标是保证吞吐量和周转时间。

1. **先来先服务算法**：FCFS，从就绪队列中选择一个最先进入该队列的进程，分配CPU，非抢占式。
2. **短作业(进程)优先调度算法**：从就绪队列中选出一个最短运行时间的进程，抢占式。
3. **最高响应比优先**：响应比R=1 + (等待时间/处理时间)，是先来先服务和短作业优先两者的结合，非抢占。

#### 交互式系统：有大量的用户交互操作，目标是快速地进行响应。

1. **时间片轮转法**：让每个进程轮流执行一段时间，抢占。
2. **最高优先级调度算法**：选择优先级最高的投入运行。
3. **多级反馈队列调度算法**：结合了最高优先级和时间片轮转调度算法。每个队列有不同的优先级和时间片长度。
4. **完全公平调度算法**：Linux现在的进程调度算法，根据权重分配不同的时间片。
   - 含义：拥有最小vruntime的进程代表受到了CPU不公平的对待，所以会被优先调度。
   - 每个进程都对应一个权重（nice值），nice值越大，权重越低。
   - 每个进程对应一个vruntime（虚拟运行时间，根据进程的权重将实际已运行时间放大或者缩小一个比例得出来）。vruntime的顺序由红黑树来维护。



## 6. 死锁

**死锁的四个必要条件**：

1. 互斥：一个资源每次只能被一个进程使用。
2. 占有且等待：因请求资源而阻塞的进程不释放已获得的资源。
3. 不剥夺：不能强行剥夺其他进程已获得的资源。
4. 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系。

**死锁的预防**：破坏上述四个条件

- 破坏占有且等待条件，给锁加上一个超时时间，超时则放弃资源，然后等待一段随机的时间再重试。
- 一次性请求所有需要的资源。
- 破坏循环等待条件，通过控制请求资源的**时序**预防死锁。

**死锁的避免**：进程启动拒绝、资源分配拒绝

- 银行家算法：当一个进程申请使用资源的时候，银行家算法通过先**试探**分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。
- 安全状态：即使所有进程突然请求对资源的最大需求，也一定**存在某种调度次序**能够使得每一个进程运行完毕，则称该状态是安全的。

**死锁的检测和解除**：不阻止死锁发生，而是检测到发生了之后再去解除。

- 死锁的检测：每当一个线程获得资源，用一个图来记下，再通过检测环的存在检测死锁。
- 死锁的解除：撤销进程、剥夺资源



## 7. 虚拟内存

1. 目的：为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

2. 页：为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。

   这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都在物理内存中。

   如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。

3. 页表：存储着页（程序地址空间）和页框（物理内存空间）的映射表。

4. 页面置换算法：页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。

   - LRU（Least Recently Used）：将最久未使用的页面换出。
   - NRU（Not Recently Used）：先换出没写和没读的，其次是被写的。通过两个写/读状态位分成4类。
   - FIFO（First In First Out）：将最先进入的页面换出，可能会把经常使用的页面换出。



## 8. 杂

cache和buffer的区别：

- Cache：缓存，对于经常访问的数据，缓存用来减少对低一层存储设备的重复读取次数。
- Buffer：缓冲区，跟读写相关，生产者和消费者对资源的生产/消费速率不一致