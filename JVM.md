# JVM

## 1. 内存区域 

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F.png" alt="img" style="zoom: 67%;" />

#### 线程私有内存：

1. 程序计数器：指向当前线程所执行的字节码位置。

2. 虚拟机栈：Java方法执行的内存模型，传递方法调用所需的数据。每执行一个方法都会创建一个栈帧，方法的执行与完成伴随着栈帧的出栈入栈。

   - 每个栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。局部变量表包含基本数据类型、对象引用。

   - 错误：StackOverflowError、OutOfMemoryError

3. 本地方法栈：结构和虚拟机栈几乎一致。虚拟机栈为Java方法服务，本地方法栈为Native方法服务。

#### **线程共享内存**：

1. 堆：唯一目的就是存放对象实例，是垃圾收集器管理的主要区域。
   - 错误：OutOfMemoryError
   
2. 方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码。是永久代的一种实现方式。在JDK1.8以后被元空间代替，元空间使用的是直接内存。
   
   - class文件信息：包括**类元信息**和**静态常量池**。类元信息是class文件内容的一个框架，里面具体的内容通过静态常量池来存储。
   
   - 运行时常量池：包含字面量（文本字符串、Final修饰的变量等）、符号引用。当Class文件被加载完成后，Java虚拟机会将静态常量池里的内容转移到运行时常量池里，在静态常量池的符号引用中一些不能被重写的部分被转变为直接引用。

#### **直接内存（堆外内存）**：

不属于JVM定义的内存区域，不由JVM管理和回收。NIO类可以直接使用Native函数库来分配堆外内存，然后通过一个存储在Java堆内的DirectByteBuffer对象作为对这块内存的引用，从而进行操作。



## 2. 类加载器

JVM内置3个重要的类加载器，BootstrapClassLoader、ExtensionClassLoader、AppClassLoader。

- 启动类加载器：java.*开头的类均被Bootstrap ClassLoader加载。
- 扩展类加载器：如javax.*开头的类。
- 应用程序类加载器：它负责加载用户类路径（ClassPath）所指定的类，一般情况下这个就是程序中**默认**的类加载器。
- 用户自定义类加载器：一般用不到，应用服务器大都使用了自定义的ClassLoader技术。

#### 双亲委派模型：

每一个类都有一个对应的ClassLoader。系统中的ClassLoader在协同工作时默认采用双亲委派模型。

1. 判断类是否被加载过，如果已经被加载过则直接返回，否则才会尝试加载。
2. 加载的时候，子类加载器不会自己尝试加载这个类，会把请求委派给该父类加载器的loadClass()处理，因此所有的请求最终都会传送到顶层的BootstrapClassLoader中。只有当父类加载器无法处理时，子类加载器才会去尝试加载。
3. 当父类加载器为null时，会使用启动类加载器BootstrapClassLoader作为父类加载器。

> 这里的“双亲”表示的是“父类”的意思。另外类加载器之间的父子关系也不是通过继承来体现的，而是由“优先级”来决定。另外这里说的都是类的加载，与对象无关。

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/classloader_WPS%E5%9B%BE%E7%89%87.png" alt="ClassLoader" style="zoom:75%;" />

#### 双亲委派模型的好处：

保证了Java程序的稳定运行，避免了类的重复加载，保证了Java API核心不被篡改。



## 3. 类加载过程

所有的类都由类加载器加载，加载的作用就是将.class文件加载到虚拟机内存。系统加载Class类型的文件分三步：加载 —>连接—>初始化。连接过程也分三步：验证—>准备—>解析。

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="类加载过程" style="zoom:67%;" />

#### 加载：

1. 通过类名来获得定义此类的二进制字节流。
2. 将字节流代表的静态存储结构转换为方法区的**运行时**数据结构。
3. 在Java堆中生成一个代表该类的java.lang.Class类对象，作为方法区这些数据的访问入口。

> 加载和连接阶段的部分内容是交叉进行的。

#### 连接：

1. 验证：文件格式验证 —> 元数据验证 —> 字节码验证 —> 符号引用验证 。

2. 准备：正式为类变量分配内存并设置类变量初始值，这些内存都将在方法区中分配。此时的“初始值”指的是当前数据类型默认的零值，初始化阶段才会赋我们设置的初始值。

3. 解析：虚拟机将常量池内的符号引用替换为直接引用（内存地址指针/偏移量）。

#### 初始化：

初始化阶段是执行类构造器clinit()方法的过程，该方法为带锁线程安全，所以可能引发死锁。



## 4. 对象的创建过程

#### 对象的创建：

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="Java创建对象的过程" style="zoom:80%;" />

1. 类加载检查：检查**常量池**，定位到这个类的符号引用，并且检查该类是否已被加载过。如果没有，则必须执行相应的类加载过程。
2. 分配内存：类加载完成后即可确定所需内存大小，从Java堆中划分出来。
   - 分配方式：指针碰撞、空闲列表。
   - 并发问题，保证线程安全的方式：CAS+失败重试、TLAB
3. 初始化零值：保证对象实例的字段不赋初始值就能直接使用。
4. 设置对象头：对象头包括对象所属类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。
5. 执行init方法：执行new指令之后会接着执行init方法，创建对象。

> MyObject k = new MyObject();
>
> 从下往上进行类加载检查，已加载则直接返回，未加载则从上往下的尝试用类加载器加载 ——> 将.class文件加载到方法区中 ——> 将文件里的一些静态信息转换到运行时常量池中 ——> 在堆上创建一个Class类对象 ——> 将常量池内的符号引用替换为直接引用 ——> 在堆上创建一个MyObject对象 ——> 初始化零值 ——> 设置对象头 ——> 执行init。

#### **对象的访问**：

Java程序通过栈上的reference数据来访问堆上的具体对象。对象的访问方式由虚拟机的实现方式而定。目前主流的访问方式有使用句柄、直接指针两种。

1. 句柄：Java堆中划分出内存作为句柄池，栈中的reference存储对象的句柄地址，句柄中包含了对象的实例数据地址（堆）和类型数据地址（方法区）信息。
2. 直接指针：栈中的reference存储对象实例的地址，同时需要一个指针访问对象类型数据的信息。



## 5. 垃圾回收

#### 区域分配：

为了更好的回收/分配内存，Java堆可分为新生代和老年代，又可细分为Eden、From Survivor(s0)、To Survivor(s1)，Tentired（老年代）。这么设计主要是为了延缓对象到老年代的过程，从而减少old gc。

经过一次MinorGC后，Eden区和s0区将被清空，此时s0和s1将交换角色（复制算法）。

<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3%E5%A0%86%E7%BB%93%E6%9E%84.png" alt="img" style="zoom:80%;" />

1. **对象优先在Eden区分配**。

   当Eden区没有足够空间进行分配时，虚拟机将发起一次minor GC。

   - Minor GC：新生代的垃圾收集，很频繁。
   - Major GC/Full GC：老年代的垃圾收集，伴随着至少一次的minor GC。

   如果GC期间发现Survivor空间也不足，虚拟机通过**分配担保机制**将新生代对象提前转移至老年代。

2. **大对象直接进入老年代**。避免由于分配担保机制带来的复制。

3. **长期存活的对象进入老年代**。

   对象在Eden区域分配，在一次minor GC之后，如果对象还存活，则会进入s1区，他的年龄会加1。每经历一次minor GC年龄就增长1岁，当年龄增长到一定程度（默认15岁），则会进入老年代中。

4. 动态年龄阈值判定。

   为了更好的适应内存情况，如果survivor空间中相同年龄的所有对象所占空间的总和大于Survior空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。
   
5. 一般young区和old区的比例为1：2；Eden区、s0区、s1区的比例是8：1：1。



#### 判断无用的类：

需要同时满足以下3个条件才算是无用的类：

1. 所有的实例都被回收，即Java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已被回收。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



#### 判断对象死亡：

对Java堆垃圾的回收第一步需要判断哪些对象已经死亡。

1. **引用计数法**：给对象添加一个引用计数器，每当有一个地方引用该对象，计数器就加1；当引用失效就减1。任何时候计数器为0的对象就是不可能再被使用的。（很难解决对象之间相互引用的问题）
2. **可达性分析算法**：和GC Roots有直接或间接关联的对象都是有效的，没有关联的就是无效对象。可作为GC Roots的对象包括以下4种：
   
   - 虚拟机栈中引用的对象
   - 本地方法栈中引用的对象
   - 方法区中类静态属性引用的对象
   - 方法区中常量（final修饰）引用的对象
3. **引用分类**
   
   - 强引用：最普遍使用，不会被垃圾回收器回收。
     
     - 如果一个强引用为全局变量，需要在不使用它时把它赋值为null，因为强引用不会被回收。
     
   - 软引用：具有软引用的对象，当内存空间不足时会被回收（可以用来缓存数据）。与引用队列联合使用。
   
   - 弱引用：无论空间是否足够，都会回收该对象的内存。与引用队列联合使用。
   
   - 虚引用：和没有引用一样，随时可能被回收。与引用队列联合使用。
   
     >创建一个引用队列，当引用的对象将要被JVM回收时，会将这个引用加入到引用队列中，所以通过引用队列可以了解JVM垃圾回收情况。



#### 垃圾收集算法：

1. **标记-清除算法**：分为两个阶段，首先标记出所有需要被回收的对象，在标记完成后统一回收被标记的对象。最基础的收集算法，后续算法都是对其不足的改进得到。该算法存在的问题：
   - 效率问题
   - 空间问题（标记清除后产生大量不连续的碎片）
2. **复制算法**：为了解决效率问题。将内存一分为二，每次只使用其中一块，当使用完后将还存活的对象复制到另一块区，然后将使用的空间一次清理掉。每次回收都是对空间的一半进行回收。
3. **标记-整理算法**：标记过程与标记-清除算法一样，然后让所有存活的对象向一端移动，然后清理掉端边界以外的内存。
4. **分代收集算法**：根据各个年代的特点选择合适的垃圾收集算法。
   - 新生代：每次收集都有大量对象死去，所以可以选择**复制算法**，每次只需要复制少量对象即可完成GC。
   - 老年代：存活几率比较高，而且没有额外空间，必须选择**标记-清除或者标记-整理**算法进行GC。



#### 垃圾收集器：

| 种类               | 范围       | 单/多线程  | 处理算法  | 侧重点            |
| ------------------ | ---------- | ---------- | --------- | ----------------- |
| Serial             | 新生代     | 单线程     | 复制      | 适用于Client 模式 |
| ParNew             | 新生代     | 多线程并行 | 复制      |                   |
| Parallel Scanvenge | 新生代     | 多线程并行 | 复制      | 吞吐量            |
| Serial Old         | 老年代     | 单线程     | 标记-整理 |                   |
| Parallel Old       | 老年代     | 多线程并行 | 标记-整理 |                   |
| CMS                | 老年代     | 多线程并发 | 标记-清除 | 停顿时间          |
| G1                 | 整个Java堆 | 多线程并发 | 复制      | 停顿时间          |



#### CMS垃圾收集器：

CMS（Concurrent Mark Sweep）收集器是一种以获取**最短回收停顿时间**为目标的收集器。这是因为CMS收集器工作时，GC工作线程与用户线程可以并发执行，以此来达到降低收集停顿时间的目的。CMS只工作在老年代。

CMS收集器仅作用于老年代的收集，是基于标记-清除算法的，它的运作过程分为4个步骤：

- 初始标记：标记所有老年代的GC Roots；
- 并发标记：由初始标记找出所有存活的对象，并把引用关系发生变化的Card（一块区域）标识为dirty；
- 预清理：扫描所有标记为Dirty的Card；
- 重新标记：完成标记整个年老代的所有的存活对象。 这个阶段，重新标记的内存范围是整个堆；
- 并发清除：并发清除那些没有标记的对象并且回收空间。



#### G1垃圾收集器：

1. JDK1.7后全新的回收器，用于取代CMS。G1的初衷是为了尽量**缩短处理超大堆时产生的停顿**，满足用户设定的gc停顿时间。
2. G1不再把内存区域分成Eden、Survior、old三大块，而是把堆内存**切分成很多个固定大小的区域**（Region）。每个区域都是一块连续的内存，默认均分成2048份。G1最大的特点就是高效的执行回收，优先去回收那些大量对象可回收的region。
3. 每个Region都被标记了Eden、Survivor、Old。每次GC存活的对象从一个Region复制到另一个Region。
4. G1提供了两种GC模式，Young GC和Mixed GC，两种都是Stop The World（所有线程会被暂停）。
5. **Young GC**会回收Eden以及Survivor区，并且将存活对象复制到另一部分的Survivor区或是Old区。
6. **Mixed GC**不是full GC，它只能回收部分老年代的Region。当Mixed GC的速度实在跟不上程序分配内存的速度时，会使用Serial Old GC（full GC）来收集整个Java堆。
7. G1回收流程：
   - **初始标记**：STW，标记出从GC Roots开始直接可达的对象。
   - **并发标记**：不暂停其他线程，从初始标记开始一层一层的标记出存活对象。
   - **最终标记**：STW，并发标记的过程中用户程序可能修改了对象引用关系，最终标记标记出那些在并发标记阶段发生变化的对象，使它们能正确被回收。
   - **筛选回收**：STW，首先对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region。


